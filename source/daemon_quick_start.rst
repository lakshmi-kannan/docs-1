Quick Start Guide
=================
Quick start guide to create a new daemon within flexswitch

.. image:: images/daemon.png

This guide helps you to create a small daemon skeleton which would run as part of FlexSwitch.
The daemon is named as Example Daemon.  This daemon is assumed to belong to layer 2
of the networking stack, so we make this daemon under $SR_CODE_BASE/src/l2

Create Model Objects
^^^^^^^^^^^^^^^^^^^^
First step in writing a daemon is to define the data model.

Our datamodel would consist of the objects that represent state and configuration of the daemon. 

Here we would create our model in a golang source file in $SR_CODE_BASE/models repo under objects directory.

File name for the below example **exampleObjects.go**

Example

::

 package objects
 
    /*
     * Config object of exampled
     */
    type Example struct {
        baseObj
        VlanId        int32    `SNAPROUTE: "KEY", ACCESS:"w", MULTIPLICITY: "*", MIN:"1", MAX: "4094", DESCRIPTION: "802.1Q tag/Vlan ID for vlan being provisioned"`
        IntfList      []string `DESCRIPTION: "List of interface names or ifindex values to  be added as tagged members of the vlan"`
        UntagIntfList []string `DESCRIPTION: "List of interface names or ifindex values to  be added as untagged members of the vlan"`
    }
    
    /*
     * State object of exampled
     */
     type ExampleState struct {
        baseObj
        VlanId        int32    `SNAPROUTE: "KEY", ACCESS:"r", MULTIPLICITY: "*", DESCRIPTION: "802.1Q tag/Vlan ID for vlan being provisioned"`
        IntfList      []string `DESCRIPTION: "List of interface names or ifindex values to  be added as tagged members of the vlan"`
        UntagIntfList []string `DESCRIPTION: "List of interface names or ifindex values to  be added as untagged members of the vlan"`
    }
    

Look at the "ACCESS" tag in above objects. 

An access type of "w" is considered as a configuration object and "r" as a state object.

Configuration objects can be created/updated/deleted, where as state objects can be only queried.

An object can have access type as "rw" as well. Objects with access type as "rw" are considered as configuration as well as state objects.

State objects should have "State" appended to the object name. E.g. ExampleState.

Add Model Object to Daemon Map
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Now that we have defined the model, we need to let the system know that the 'Example Daemon' is responsible for the functionality.
So we specify that these objects have an owner. As mentioned in the 'Architecture' section we use thrift as our RPC. So we need to specify
path to a generated thrift file.

Add the following lines to **models/objects/goObjinfo.json** before localObjects entry

Example

::

    "exampleOjects.go" :  {"owner":     "exampled",          
                           "location" : "l2/example/rpc",
                           "svcName"  : "nil"},           


Add module to thirft client handle
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
ConfigManager in FlexSwitch needs to delegate the REST APIs to the new daemon. So we need to update the clients of ConfigManager

Add the following lines to **config/cliens/clientmap.go**

::

    "exampled":    &EXAMPLEDClient{},

Add module to client port list
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
In addition to the ConfigManager there would be other modules like system daemon that would communicate with the new daemon.
To let the other daemons know the existance of 'Example Daemon' we need to update  
**config/params/clients.json** 

Pick a port number that does not conflict with any other port within the json. Make sure the port is not used by any other client or any service in your system.

Example

::

    {"Name":"exampled",
     "Port":10018},


Build Example Daemon Skeleton Back-End Code
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Skeleton daemon code can be autogenerated by executing below command:

::

    cd $SR_CODE_BASE/relctools
    python codegentools/daemon/daemon.py -d exampled -r l2 -o exampleObjects.go


Usage of daemon.py is as shown below

::

    Usage: daemon.py [options]

    Options:
      -h, --help            show this help message and exit
      -d DAEMON, --daemon=DAEMON
                            Name of the daemon
      -m MODULE, --module=MODULE
                            Name of the module
      -r REPO, --repo=REPO  Name of the repo this demon belongs to
      -o OBJECTS, --objects=OBJECTS
                            Name of the file containing config objects for this
                            daemon


Daemon name is mandatory parameter in daemon.py script.
If the daemon is part of any particular repo, e.g. as described above exampled is part of l2,
then repo name should be provided.
If we want to have different name for the module than the daemon name then module name should be provided.
By default, module name is derevived from daemon name by dropping last character 'd'. For example, if daemon name is "exampled" the module name will be "exampl"
If the daemon has config objects defined in a file then that can be passed to the script as objects.
Here we are passing exampleObjects.go.

- Verify directory structure is created for this daemon. Directories created are -
    - $SR_CODE_BASE/snaproute/src/repo/module
        - Verify main.go and Makefile are created
    - $SR_CODE_BASE/snaproute/src/repo/module/server
        - Verify server.go file created
    - $SR_CODE_BASE/snaproute/src/repo/module/rpc
        - Verify rpc.go and rpcHdl.go files are created 


Build Example Daemon Code for ConfigMgr
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

To generate code used by ConfigMgr, execute below commands:

::

    make codegen                                                      
    make ipc                                                          


- Verify that within l2/exampled/rpc directory that there is a thrift file **exampled.thrift** created.
      - For each object with access type as "w", there should be CreateXXX, UpdateXXX, and DeleteXXX APIs in EXAMPLEDServices thrift service.
      - For each object with access type as "r", there should be GetBulkYYY and GetYYY APIs in EXAMPLEDServices thrift service.
- Verify in models/objects that you see something similar to the following
    - gen_Exampledbif.go
    - gen_ExampleStatedbif.go
    - gen_exampledObjects_serializer.go
    - gen_exampledthriftutil.go
- Verify FlexSdk repo to see if APIs are generated for the above Objects in **flexSdk/py/flexprintV2.py** and **flexSdk/py/flexSwitchV2.py**




Add Module to Top Level Repo Makefile
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
We want this module to be part of other l2 components. So edit Makefile under l2/ directory as follows.

Add the following line to COMPS

        example

Add the following lines to IPCS

        example
        


Package module into FlexSwitch
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
We need to add ExampleDaemon to the top level Makefile so that it can be picked up for packaging
Make these changes on the top level Makefile as follows.

::

    install $(SRCDIR)/$(BUILD_DIR)/exampled $(DESTDIR)/$(EXT_INSTALL_PATH)/bin
    
    
Loading module to FlexSwitch
^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Now we need to make the ExampleDaemon start on every FlexSwitch instantiation. 
This can be done by editing flexswitch script under $SR_CODE_BASE/reltools/ directory
as  follows. Make sure to change runlevel to avoid conflict.
    
 ::
       {'name': 'fMgrd',
        'runlevel' : 17, 
        'params': '-params=' + baseDir + '/params'},

       {'name': 'exampled',
        'runlevel' : 18, 
        'params': '-params=' + baseDir + '/params'},

       {'name': 'confd',
        'runlevel' : 19, 
        'params': '-params=' + baseDir + '/params'},

Now you should be able to see your daemon running as part of the FlexSwitch along with the other daemons.

